= Building Middleware

NOTE: This page is very incomplete and a work in progress.

== Overview

This part of the documentation aims to guide you in the process of implementing
nREPL middleware. We'll cover the basics, the best practices and some of the common pitfalls you might
encounter.

NOTE: This page complements xref:design/middleware.adoc[the middleware design documentation]. Make sure you're
familiar with it before proceeding to implement any middleware.

== Basics

== Testing

== Best Practices

In this section we'll go over some of the best practices for implementing nREPL middleware.

=== Code Structure

It's best to keep the business logic decoupled from the middleware code and have middleware
serve as a thin wrapper around it. This means that ideally you should have the business logic
in a different namespace (or even a different library). A good example would be the completion
middleware bundled with nREPL:

* The actual completion logic lives in `nrepl.util.completion`
* The middleware code lives in `nrepl.middleware.completion` and it simply delegates to
`nrepl.util.completion`

This separation makes it easier to test the business logic in isolation and to re-use it outside
of nREPL (a good example here would be the `orchard` library that `cider-nrepl` uses heavily).

As a corollary - you should avoid creating middleware that provides a lot of unrelated functionality.
Ideally all ops within some middleware should be closely linked by their purpose.

=== Naming conventions

It's recommended to prefix middleware names with `wrap` - e.g. `wrap-complete`, `wrap-lookup`, etc.
This naming convention came from https://github.com/ring-clojure/ring/wiki/Concepts#middleware[Ring middleware],
which was a major influence on the design of nREPL.

NOTE: nREPL itself breaks this convention with names like `add-stdin` and `interruptible-eval`, but
those names are historical and hard to change at this point.

When it comes to ops, ideally their names should be verbs - e.g. `complete`, `lookup`, `test`, etc.
Related ops can be grouped under some common prefix - e.g. `test-var`, `test-ns`, `test-all`.

It's also prudent to prefix op names with some "namespace"-like prefix to avoid conflicts between
different middleware - e.g. `project-name/op-name`.

NOTE: That's the reason why nREPL's completion op is named `completion` instead of `complete`.
`cider-nrepl` already has an op named `complete` and adding such an op to nREPL would have introduced
some non-deterministic behaviour when it comes to the ordering of the two competing completion middleware.
As a result, in some cases you'd be invoking nREPL's op and in other cases `cider-nrepl`'s op.
If `cider-nrepl` had named the op `cider/complete` instead, that would have prevented this unfortunate
situation.

== Additional Resources

* https://metaredux.com/posts/2019/12/04/documenting-nrepl-middleware-apis.html
